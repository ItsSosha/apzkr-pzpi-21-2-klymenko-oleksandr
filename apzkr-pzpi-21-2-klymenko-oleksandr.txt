Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для моніторингу стану та персоналізації досвіду клієнтів мережі спортивних залів

Студент гр. ПЗПІ-21-2	__________________ Клименко О. А.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Клименку Олександру Анатолійовичу
1.	Тема роботи: «Програмна система для моніторингу стану та персоналізації досвіду клієнтів мережі спортивних залів»		
2.	Термін узгодження завдання курсової роботи «26»_лютого__ 2024 р.
3.	Термін здачі студентом закінченої роботи «31»___травня____ 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
Створена програмна система має мати наступні можливості: можливість моніторингу стану клієнтів залу, отримання рекомендацій згідно з отриманими показниками, перегляду аналітичних даних по тренуванню, корисні статті для користувачів, інтернаціоналізація, адміністрування системи та її масштабованість. При розробці використовувати СКБД PostgreSQL, середовище розробки Visual Studio Code. Система має складатися з 4 компонентів (Back-end, Front-end, Mobile app, IoT)	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз та концептуальне моделювання предметної області, проєктування програмної системи, розробка серверної частини системи, розробка програмного забезпечення для вбудованих систем, розробка клієнтського веб-застосунку, розробка мобільного застосунку, висновки, перелік використаних джерел, додатки	
Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання системи, UML діаграма прецедентів серверної частини, ER-діаграма, UML діаграма пакетів серверної частини, UML діаграма прецедентів частини для вбудованих систем, UML діаграма взаємодії частини для вбудованих систем, UML діаграма станів частини для вбудованих систем, UML діаграма діяльності частини для вбудованих систем, Схема фіізичної моделі частини для вбудованих систем, UML діаграма прецедентів веб клієнту, UML діаграма компонентів веб-клієнту, UML діаграма пакетів веб-клієнту, UML діаграма діяльності веб-клієнту, UML діаграма прецедентів мобільної частини, UML діаграма компонентів мобільної частини, UML діаграма пакетів мобільної частини, UML діаграма діяльності мобільної частини	
 
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	22.03.2024	виконано
2	Проектування програмного
проекту	12.04.2023	виконано
3	Кодування програмного проекту	26.04.2023	виконано
4	Оформлення пояснювальної
записки	17.05.2023	виконано
5	Захист курсової роботи	31.05.2023	виконано

Дата видачі завдання «26» лютого 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________            Клименко О. А.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 78 с., 17 рис., 2 додатки, 6 джерел.
СПОРТ, МОНІТОРИНГ, ТРЕНУВАННЯ, NESTJS, REACT, JETPACK COMPOSE, ESP32.
Метою курсового проєкту є створення програмної системи для моніторингу стану та персоналізації досвідку клієнтів мережі спортивних залів.
Під час розробки для кожної частини було використано широкий перелік технологій, зокрема PostgreSQL в якості СКБД, NestJS з TypeScript для серверної частини, мікроконтролер ESP32 в якості платформи для IoT-пристрою, ReactJS з TypeScript для реалізації браузерної клієнтської частини та фреймворк Jetpack Compose для Kotlin при розробці мобільного застосунку.
Результатом роботи стала програмна система, що дозволяє клієнтам мережі спортивних залів відстежувати історію власних тренувань, показники свого тіла протягом цих тренувань, отримувати персоналізовані рекомендації згідно з ним та переглядати наявні у застосунку статті. Керівники мережі, використовуючи браузерний застосунок для адміністрування системи мають змогу додавати нові заклади, керувати наявними у застосунку статтями та додавати нові, керувати доступ до адміністраторської панелі та створювати нові резервні копії бази даних. Обидві клієнтські частини підтримують локалізацію для української та англійської мов.
 
ЗМІСТ


ЗМІСТ	6
ВСТУП	8
1	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1	Бізнес-вимоги	9
1.1.1.	Передумови	9
1.1.2.	Бізнес-можливості	10
1.1.3.	Бізнес-цілі та критерії успіху	11
1.1.4.	Потреби клієнтів та ринку	11
1.1.5.	Бізнес-ризики	12
1.2	Концепція рішення	13
1.2.1.	Окреслення концепції	13
1.2.2.	Головна функціональність	14
1.2.3.	Припущення та залежності	15
1.3	Рамки та обмеження	16
1.3.1.	Рамки первинного випуску	16
1.3.2.	Рамки наступних випусків	17
1.3.3.	Обмеження та Виключення	18
1.4	Бізнес-контекст	19
1.4.1.	Профілі зацікавлених сторін	19
1.4.2.	Пріоритети проєкту	21
1.4.3.	Робоче середовище	22
2	ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ	24
2.1.	Опис архітектури системи	24
2.2.	Побудова діаграми розгортання	24
3	РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ	26
3.1.	Опис архітектури серверної частини системи	26
3.2.	Побудова діаграми прецедентів для серверної частини системи	27
3.3.	Побудова ER-діаграми для серверної частини системи	27
3.4.	Специфікація REST	28
3.5.	Побудова діаграми пакетів для серверної частини системи	30
4	РОЗРОБКА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ ВБУДОВАНИХ СИСТЕМ	32
4.1.	Концептуальне моделювання системи	32
4.2.	Опис розробки застосунку для вбудованих систем	32
4.2.1.	Обґрунтування архітектурних рішень проєкту	32
4.2.2.	Опис використаних технологій	33
4.2.3.	Опис результатів розробки частини проекту для вбудованих систем	33
4.2.4.	Опис результатів тестування частини проекту для вбудованих систем	34
5	РОЗРОБКА КЛІЄНТСЬКОГО ВЕБ-ЗАСТОСУНКУ	35
5.1.	Концептуальне моделювання системи	35
5.2.	Опис розробки клієнтського веб-застосунку	35
5.2.1.	Обґрунтування архітектурних рішень проєкту	35
5.2.2.	Опис використаних технологій	36
5.2.3.	Опис результатів розробки клієнтського веб-застосунку	37
5.2.4.	Опис результатів тестування клієнтського веб-застосунку	38
6	РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ	39
6.1.	Концептуальне моделювання системи	39
6.2.	Опис розробки мобільного застосунку	39
6.2.1.	Обґрунтування архітектурних рішень проєкту	39
6.2.2.	Опис використаних технологій	40
6.2.3.	Опис результатів розробки мобільного застосунку	41
6.2.4.	Опис результатів тестування мобільного застосунку	42
ВИСНОВКИ	43
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ	44
ДОДАТОК А	45
ДОДАТОК Б	61


 
ВСТУП


Сучасна фітнес-індустрія зіштовхується з викликом створення персоналізованого та ефективного досвіду тренувань для своїх клієнтів. Існуючі рішення часто не забезпечують комплексного підходу до моніторингу стану здоров'я, відстеження прогресу та індивідуальних рекомендацій, що обмежує можливості як відвідувачів, так і власників спортивних залів.
Програмна система для моніторингу стану та персоналізації досвіду клієнтів мережі спортивних зал покликана вирішити цю проблему, пропонуючи інноваційний підхід до управління тренувальним процесом. Вона об'єднує в собі функціональність відстеження історії тренувань, аналізу показників зі смарт-пристроїв, надання персоналізованих рекомендацій та доступ до інформаційних матеріалів.
Для власників спортивних залів система відкриває нові можливості для підвищення якості обслуговування, утримання клієнтів та оптимізації бізнес-процесів. Вона дозволяє ефективно керувати мережею залів, контентом та комунікацією з клієнтами, що сприяє розвитку та успіху бізнесу.
Впровадження цієї системи є ключовим кроком у напрямку створення сучасного, ефективного та клієнтоорієнтованого фітнес-простору. Вона дозволяє досягти нових висот у персоналізації тренувань, підвищенні мотивації та залученості клієнтів, що є запорукою успіху як для відвідувачів, так і для власників спортивних зал.
 
1	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1.	Передумови


У сфері фітнесу та спортивних закладів існує велика кількість програм та систем, спрямованих на вдосконалення процесів обслуговування клієнтів та оптимізацію роботи персоналу. Однак, багато з цих систем стикаються з проблемою складності використання для звичайних користувачів. Бажання зробити систему якомога більш функціональною та ефективною часто призводить до великої кількості налаштувань та можливостей, що ускладнює її розуміння та використання клієнтами з різним рівнем технічної підготовки або ж призводить до отримання користувачем нерелевантної та непотрібної інформації, як наприклад набридливі сповіщення. Або ж інколи користувачі стикаються з занадто складної системою звітності, що вимагає наявності більш глибоких знань у сфері харчування та фізичних вправ, через що вона не стає їм у пригоді. І найважливішим є забезпечити достовірність інформації, що надає система, оскільки користувачі, стикаючись із недостовірною інформацією, що не допомагає досягати їхніх спортивних цілей, дуже швидко перестануть користуватись застосунком.
Таким чином, проблема полягає в створенні програмної системи для моніторингу стану та персоналізації досвіду клієнтів спортивного залу, яка б не лише надавала широкий функціонал для оптимізації роботи закладу, але й залишалася простою та зрозумілою для будь-якого користувача, незалежно від їхнього рівня технічної експертизи, а також збагачувала досвід відвідування спортивної зали. А для самої мережі дана система допоможе зберегти лояльних клієнтів та привабити багато нових, розширюючи свою клієнтську базу.



1.1.2.	Бізнес-можливості


Аналоги на ринку:
−	GymShark: застосунок від однойменного фітнес-бренду, який пропонує можливості відстеження тренувань та харчування. З переваг має простий у використанні інтерфейс та пропонує безкоштовні плани тренувань. Але значним недоліком є відсутність функцій моніторингу стану клієнтів на рівні спортзалу, таких як відстеження відвідувань або прогресу.
−	Trainerize: платформа для онлайн-тренерів та персональних тренерів, яка допомагає їм створювати та керувати індивідуальними планами тренувань та харчування для своїх клієнтів. З переваг має високий ступінь персоналізації, можливість зворотнього зв’язку між тренером та клієнтом, багатий функціонал по рекомендаціям. Але подана система є достатньо дорогою у використанні, що може стати перешкодою для багатьох користувачів. Також вона більш націлена на тренерів, які хочуть покращити зв’язок із своїми клієнтами, аніж на самих клієнтів.
−	FitMe: мобільний застосунок, який пропонує персоналізовані плани тренувань та харчування на основі даних про користувача, таких як вік, вага, рівень фізичної підготовки та цілі. Система має гарну спільноту користувачів, а також є доступною. З суттєвих недоліків можна перелічити відсутність наукового обгрунтування планів тренувань та харчування у застосунку, поганий інтерфейс, що заважав користуванню функціоналом, а також наявність небезпечних рекомендацій, що можуть призвести до проблем зі здоров’ям у деяких людей
Переваги продукту в порівнянні з наведеними вище аналогами на ринку полягають у зручності його використання (мобільний застосунок), доступності для різних бюджетів, гарній персоналізації та порадам на основі датчиків, що знімають показники у реальному часі, простоті. Також перевагою є те, що система буде безпосередньо інтегрована для певної мережі спортивних залів, що відкриває нові можливості для її власників у маркетингу та просуванні їхніх товарів.
Прибуток від системи буде отримуватися за рахунок підписок, що будуть реалізовані у наступних випусках, а також можливостей розміщення рекламного контенту безпосередньо у застосунку від партнерів мережі.


1.1.3.	Бізнес-цілі та критерії успіху


Завдяки створеному застосунку планується підвищити кількість продажів абониментів мережі спортивних залів на 30% та значно підвищити її видимість у соціальних мережах за рахунок контенту, який буде поширюватися зацікавленими користувачами. Критерієм успіху буде завантаження застосунку щонайменш 70% сталими клієнтами мережі та за результатами перших випусків отримання оцінки в якості не менше 4.5 зірок.


1.1.4.	Потреби клієнтів та ринку


a)	Потреби користувачів:
1)	Регулярні відвідувачі спортивних закладів: особи, які регулярно відвідують спортивний зал і шукають зручний спосіб для моніторингу свого фізичного стану та досягнень у тренуваннях. Ця група користувачів зацікавлена у здобутті зручного інструменту, що полегшить їх процес тренувань та допоможе зосередитися на досягненні власних спортивних цілей, надаючи інформацію у доступному для новачків вигляді.
2)	Тренери та інструктори: фахівці, які працюють у спортивних закладах і бажають мати доступ до інструментів для відстеження прогресу своїх клієнтів та надання їм персоналізованих рекомендацій. Дана група користувачів зацікавлена у полегшенні свої роботи шляхом делегування певних своїх обов’язків системі, як наприклад автоматична система порад, а також у розповсюдженні відповідних знань серед своїх клієнтів.
b)	Ринковий попит: Існує зростаючий попит на програмні рішення для оптимізації тренувань та підвищення ефективності тренувального процесу. Зацікавленість у здоровому способі життя та активному фізичному навантаженні також сприяє популярності таких систем.
c)	Невиконані потреби: Існують проблеми зі складністю та обмеженим функціоналом існуючих програм для моніторингу тренувань, що ускладнює їх використання для звичайних користувачів та тренерів. Багато програм також не забезпечують достатньої персоналізації для потреб кожного користувача.
d)	Сценарії використання:
1)	Користувачі створюють свої профілі в системі та вказують свої фітнес-цілі та обмеження.
2)	Система відстежує прогрес користувачів у виконанні тренувань та надає персоналізовані рекомендації для досягнення цілей.
3)	Користувачі отримують звіти та аналізи щодо їхнього фізичного стану та досягнень через мобільний додаток або веб-інтерфейс системи.


1.1.5.	Бізнес-ризики


−	Конкуренція: Ринок програмного забезпечення для спортивних закладів може бути досить насиченим, що може призвести до зниження попиту на даний продукт або зниження цін для конкуренції.
−	Проблеми безпеки даних: Збереження та обробка конфіденційних даних клієнтів (наприклад, особистих даних, медичної інформації) може стати об'єктом зловживання або кібератак, що може призвести до порушення конфіденційності та втрати довіри користувачів.
−	Виклики реалізації: Програмна система може потребувати інтеграції з іншими системами (наприклад, системами керування залом або платіжними системами), а також різноманітними апаратними засобами. Проблеми з подоланням даних викликів можуть призвести до затримок у впровадженні або недоступності деяких функцій у перших версіях продукту.
−	Зміни в споживчих потребах або технологіях: Швидкі зміни в споживчих потребах або технологіях створюють потребу у постійному їх перегляді, аби підтримувати актуальність та конкурентоспроможність програмної системи як продукту.
−	Негативний вплив на бізнес: Недостатня популярність продукту, неправильна стратегія цінування, погані відгуки на публічних платформах або високі витрати на розробку можуть призвести до фінансових проблем і навіть банкрутства.
−	Необхідність залучення додаткових фахівців: При створення подібної програмної системи дуже важливо залучити медичних та фітнес фахівців для впровадження дійсно корисного та актуального функціоналу, наповнення системи безпечним та достовірним контентом. 


1.2	Концепція рішення
1.2.1.	Окреслення концепції


При створенні даної системи за мету за мету було взято створення інноваційного, доступного продукту для клієнтів мережі спортивних залів, яке стало б для них надійним компаньйоном при впровадженні спорту та здорових звичок у їх повсякденне життя. Вона має містити інформацію про минулі відвідування зали, стан організму під час них, надавати рекомендації у вигляді корисного контенту, урізноманітнювати та робити їх тренування цікавішими. Персонал мережі ж може наповнювати застосунок корисним та рекламним контентом, обліковими записами користувачів та отримувати зворотній зв’язок від них.
Продукт складатиметься з мобільного, IoT та web застосунків, завдяки чому система міцно інтегрується у процеси керування спортивним залом та безпосередньо процес тренування.
Система в першу чергу має бути орієнтована на людей, що не мають значного досвіду у сфері спорту і допоможе їм зручно та ефективно розпочати досягати нових спортивних вершин. Таким чином вона вирішить проблеми багатьох новачків, які бояться почати займатися спортом самостійно або ж не мають достатньо коштів для забезпечення персонального тренування із тренером.


1.2.2.	Головна функціональність


MF1.	Моніторинг стану протягом тренування:
−	Система автоматично вимірює показники тіла людини протягом тренування з моменту його початку, як наприклад температура тіла.
−	На основі даних з датчиків створюється звіт у кінці тренування.
MF2.	Персоналізація:
−	Користувачі можуть надати застосунку дані про свій фізичний стан, мету тренувань та інтереси, на основі чого йому буде пропонуватися відповідний контент та поради під час тренування.
−	Користувачі також можуть налаштувати інтервал зняття показників датчиками в залежності від потреби.
MF3.	Сповіщення та аналітика:
−	Система сповіщує, якщо під час тренування були на датчиках були помітні значення не властиві здоровим процесам в організмі людини.
MF4.	Адміністрування системи:
−	Адміністрування системи завдяки браузерному інтерфейсу, що захищений автентифікацією та вимагає від користувача наявності прав адміністратора.
−	У панелі адміністратора можливо редагувати контент застосунку, додавати нові адміністраторські облікові записи тощо.
MF5.	Локалізація та інтернаціоналізація:
−	Для зручного використання користувачами різних країн, система буде підтримувати декілька мов, із легким додаванням нових.
−	Також система підтримуватиме різні міри вимірювання ваги та температури, виконуючи необхідні конвертації.


1.2.3.	Припущення та залежності


а) Припущення:
−	Припущення, що користувачі мають доступ до Інтернету та сучасних мобільних пристроїв для використання системи.
−	Припущення, що користувачі мають певний рівень знань стосовно використання спортивного інвентарю.
−	Припущення, що датчики на смарт-пристрої користувача можуть давати точні та достовірні показники в умовах активного руху та підвищеної вологості.
б) Залежності:
−	Проєкт є певним чином залежним від команди розробки, яка його реалізує та займається його довгостроковою підтримкою.
−	Проєкт залежить від виробників певних датчиків вимірювання температури та інших показників тіла людини, щоб забезпечити точність результатів вимірювань.
−	Проєкт вимагатиме залучення медичних фахівців для коректного налаштування алгоритмів порад по результам вимірювань.


1.3	Рамки та обмеження
1.3.1.	Рамки первинного випуску


У рамках первинного випуску продукту заплановано втілення низки ключових функцій, що стануть у нагоді теперішнім та майбутнім клієнтам мережі спортивних залів. До них належатиме можливість створювати власний обліковий запис, синхронізація початку тренування із системою за допомогою смарт девайсу, ще приводить у дію датчики, звіти з тренувань, досягнення,  локалізація українською та англійською мовами, можливість адміністрування системи через панель у браузері.
У серверній частині проєкту, в рамках первинного випуску, буду реалізовано можливість автентифікації та авторизації для мереж спортивних залів, що використовують створений продукт, можливість керування та створення контеном мобільного застосунку, збирання даних з датчиків клієнтів для подальшого аналізу, створення звітів з тренувань на основі зібраних даних, можливість за запитом робити резервну копію бази даних та виконувати інші адміністраційні дії. Безпека даних серверної частини буде забезпечена за рахунок регулювання доступу до ресурсів для користувачів залежно від їх прав та статусу автентифікації, а також використання надійного сервісу автентифікації для надійного збереження облікових даних.
Для користування системою в рамках первинного випуску буде створено браузерний та мобільний клієнти. Браузерна частина відповідатиме за адміністрування системи, керування користувачами, контентом, створення резервних копій бази даних та іншими ключовими налаштуваннями. Мобільний застосунок безпосередньо орієнтований на клієнтів мережі, маючи корисні поради щодо тренувань, систему досягнень та звітності щодо стану тіла під час виконання вправ протягом тренування. Також він матиме підтримувати інтернаціоналізацію і забезпечувати відповідність вимогам GDPR.
Частиною ситеми також буде IoT-пристій, що відповідатиме за зняття показників тіла людини під час тренування. Ці показники будуть оновлюватися з певним інтервалом протягом виконання вправ, а потім відправлятися на обробку до серверної частини. Після закінчення тренування згідно з отриманими даними буде згенеровано звіт.  


1.3.2.	Рамки наступних випусків


У наступних випусках продукту планується впровадження додаткових функцій, спрямованих на поліпшення користувацького досвіду та збільшення можливостей для користувачів:
−	Можливість ділитися досягненнями у соціальних мережах.
−	Підписки, що надаватимуть користувачам доступ до ексклюзивного функціоналу та контенту. Доступ до підписки буде куплятися на строк довжиною у місяць.
−	Розширена аналітика для користувачів з підпискою. Подана аналітика дозволить отримувати поради та аналізувати статистику безпосередньо протягом тренування, на основі чого можна скорегувати процес та покращити результати.
−	Функціонал спільнот, у який користувачі зможуть додавати свої малі дописи та ділитися досягненнями. Це сприятиме підвищенню мотивації та формуванню нових активних спільнот людей, що ведуть здоровий стиль життя.
−	Геолокаційні послуги для користувачів з підпиксою, що дозволять отримувати поради стосовно тренувань навіть поза спортивними залами мережі.
Поданий функціонал буде впроваджено у наступних випусках і дозволить розширити можливості застосунку та зробити його значно привабливішим для аудиторії.


1.3.3.	Обмеження та Виключення


При реалізації даного продукту наявні певні обмеження та виключення, які впливають на розробку, а також на користування створеним застосунком. Їх важливого врахувати для коректної його роботи та запобігання проблем у звичайних користувачів. З них:
−	Система значно залежить від Інтернет-з’єднання, оскільки дані для роботи вона отримує з серверу. Без нього багато функцій можуть бути недоступними або неповними. Також для майбутнього функціоналу знадобиться доступ до GPS обладнання мобільного пристрою.
−	Інтерфейс застосунку може бути недоступний для людей з обмеженими можливостями
−	Не всі датчики можуть бути сумісними із системою, на якій буде реалізовано продукт, що важливо врахувати під час безпосередньої реалізації IoT-девайсу.
−	Через індивідуальні показники кожної людини система може потребувати покращень та вдосконалень алгоритмів, по яким надаються поради, для забезпечення більшої достовірності, зокрема може повстати потреба інтеграції нових датчиків.
Ці обмеження та виключення важливо враховувати при адмініструванні та користуванні системою, щоб забезпечити її оптимально робота в умовах реальної експлуатації безпосередньо користувачами.


1.4	Бізнес-контекст
1.4.1.	Профілі зацікавлених сторін


На таблиці 1 описані профілі зацікавлених сторін:

Таблиця 1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Клієнти спортивного залу	Покращення стану здоров’я, фізичної форми, здобуття корисних знань та навичок для ведення здорового стилю життя.	Позитивне, якщо застосунок допоможе збільшити ефективність занять спортом та спостерігати за прогресом.	Отримання корисного контенту для тренувань, перегляд власного прогресу, звітів про стан з тренувань, досягнень.	Через те, що кожен з клієнтів має індивідуальні параметри, не усі поради або контент можуть бути корисними для тієї чи іншої людини.
Власники мережі спортивних залів	Збільшення кількості клієнтів мережі та утримання вже наявних, прибуток.	Позитивне, якщо продукт зможе привабити більше нових клієтів до мережі, а також виокремити її серед конкурентів.	Використання створеної системи для заохочення людей продовження користування послугами мережі, прибуток від реклами, отримання переваги над конкурентами.	Фінансові обмеження, особливо під час випуску 1.0, впливають на можливість наймати більше розробників, вимоги мають бути обговорені для можливості їх подальшої реалізації.
Розробники та технічні експерти	Підтримування чистоти коду, корисний досвід у проєктуванні та створенні застосунків.	Позитивне, якщо вимоги до продукту будуть чітко визначені, документація – актуальною, а процес розробки – злагодженим та організованим.	Корисний досвід розробки застосунків у сфері healthcare, можливість покращити власний стан здоров’я за рахунок бонусів від співпраці із бізнесом у даній сфері.	Терміни розробки, задані замовниками, можуть не відповідати заявленим вимогам до продукту, що може вплинути на його якість.
Партнери та постачальники	Збільшення продажів їхніх товарів за рахунок їх реклами та висвітлення на вітринах у залах.	Позитивне, якщо додаток допоможе їм активніше просувати власні товари серед клієнтів спортивних залів, збільшуючи продажі.	Гнучке налаштування реклами, можливість сегментації користувачів, по цілям, інтересам.	Реклама певних засобів, особливо медичного призначення може обмежуватися законодавством, реклама повинна гармонійно вписуватися у наповнення застосунку, не перешкоджаючи його користуванню.


1.4.2.	Пріоритети проєкту


На таблиці 2 наведені основні пріоритети проєкту:

Таблиця 2 – Основні пріоритети проєкту 

Показник	Опис	Пріоритет
План робіт	Випуск версії 1.0 повинен бути доступний до 31.05.2024.	Високий
Функціональність	Наявність всього заначеного функціоналу версії 1.0
	Високий
Якість	Система повинна бути стабільною, працювати без збоїв, за наявності помилок коректно їх обробляти, не перешкоджаючи своїй роботі, бути доступною цілодобово.	Високий
Персонал	На початковому етапі команда розробки складається з 1 людини	Середній
Ціна	Початкова версія продукту має незначне фінансування, за потреби існує можливість дофінансування до 15%	Середній


1.4.3.	Робоче середовище


У проєкті будуть використовуватися ряд технологій та програмних засобів для забезпечення надійності, продуктивності та доступності. Основні компоненти нашого робочого середовища виглядають наступним чином:
−	Мова програмування: Система буде розроблена використовуючи мову програмування TypeScript, що допоможе пришвидшити розробку та зробити систему більш уніфікованою за рахунок використання однієї мови програмування для серверної частини на користувацького інтерфейсу.
−	База даних: В якості СКБД буде використовуватися PostgreSQL. Це зріла, надійна, масштабована СКБД, що має широкий функціонал.
−	Фреймворк: Для розробки серверної частини буде використовуватися фреймворк NestJS, що забезпечить модульність, якість системи, а також пришвидшить та полегшить розробку.
−	Користувацький інтерфейс: Для веб-версії системи буде використано React, що допоможе зробити інтерфейс швидким та інтерактивним. Для кращого керування глобальним станом застосунку буде використана бібліотека керування станом MobX.
−	Мобільний застосунок: Для розробки мобільного застосунку буде використана мова Kotlin та фреймворк Jetpack Compose. Завдяки цьому можна буде створити кросплатформений мобільний застосунок, а мова Kotlin наразі є лідируючим вектором в Android розробці. Більш того, існують чудові навчальні матеріали для даного фреймворку безпосередньо від Google, що полегшить та пришвидшить розробку.
−	Пристрій IoT: Для його розробки буде використовуватися мікроконтролер ESP32. Ключовим фактором даного вибору є наявність інтегрованих контролерів Wi-Fi та Bluetooth, а також компактність.
−	Забезпечення безпеки: Планується використання надійних методів автентифікації та авторизації для запобігання несанкціонованому доступу до даних, а також протоколу HTTPS для безпечного надсилання даних мережею. Додатково, сприяти кращій безпеці даних може розгортання системи на віддаленому сервері.
−	Доступність та надійність: Система буде розгорнута на віддаленому сервері для можливості цілодобового доступу без значних перерв у роботі.
 
2	ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
2.1.	Опис архітектури системи


Створена система складається з 5 головних компонентів, що взаємодіятимуть між собою: серверна частина, розгорнута у хмарному середовищі база даних, браузерний та мобільний застосунки та IoT пристрій.
Увесь функціонал системи вимагає користувача пройти процедуру автентифікації. Також у системі наявні дві ролі: адміністратор, що має доступ до браузерної частини, через яку виконується адміністрування системи, та звичайний користувач, що може користуватися головним функціоналом через IoT пристрій та мобільний клієнт. 
Клієнт має мати доступ до мобільного застосунку, у якому він зможе побачити історію його тренувань, отримувати звіт у вигляді списку вимірів протягом його тренування та мати можливість отримати поради згідно з поданими вимірами.

2.2.	Побудова діаграми розгортання

Ефективність та безперебійна робота будь-якої комплексної системи, незалежно від її масштабу та призначення, значною мірою залежить від ретельного планування та професійного виконання початкового етапу її впровадження - розгортання. Це критично важливий процес, правильне виконання якого забезпечує оптимальну продуктивність системи, мінімізує ризики виникнення помилок та збоїв, а також створює міцну основу для її подальшого розвитку та масштабування.
З огляду на вищевикладене, було прийнято розгорнути серверну частину та базу даних у хмарному середовищі для забезпечення безпеки даних та безперебійної роботи ключових частин системи. 
Браузерний застосунок являє собою зібрані та оптимізовані HTML, CSS, JavaScript файли, а також інші статичні файли, що за запитом до веб-серверу повертаються браузерові, який обробляє їх та відмальовує інтерфейс. 
Мобільна частина є нативним застосунком, що встановлюється на мобільний пристрій користувача та спілкується із серверною частиною за допомогою асинхронних HTTPS запитів, забезпечуючи безпеку та не блокуючи взаємодію з інтерфейсом. 
IoT-пристрій спілкуватиметься із серверною частиною за допомогою HTTPS запитів, регулярно надсилаючи до неї актуальні дані.
На основі поданого була складена діаграма розгортання (рис. А.1).
 

3	РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
3.1.	Опис архітектури серверної частини системи


При проєктуванні для розробці серверної частини було прийнято рішення керуватися принципами N-рівневої архітектури. Таким чином забезпечується чіткий поділ відповідальності та покращує його загальну структуру.  Згідно з принципами N-рівневої архітектури було виявлено 3 головні рівні: рівень представлення, рівень бізнес логіки та рівень доступу до даних.
Рівень представлення відповідає за отримання зовнішніх запитів до серверу, витягання даних з них та їх передачу до рівню бізнес-логікіи на подальшу обробку, а також повертає результат назад користувачеві. У даному випадку цей рівень представлений у вигляді класів-контролерів, що містять методи, кожному з яких відповідає певний шлях. Дані методи є вхідними точками у серверну частину.
Рівень бізнес-логіки містить безпосередньо головну логіку системи, маніпулює  даними, отриманими з клієнтської частини та бази даних, проводить їх валідацію та повертає дані, що мають бути відправлені користувачеві.
Рівень доступу до даних представлений класами-репотизоріями, що здатні робити запити до бази даних, отримуючі інформацію про певні сутності, агрегувати дані тощо. Дані класи надаються бібліотекою TypeORM, що підтримує велику кількість СКБД, однією з яких є PostgreSQL.
Створенням об’єктів усіх з наведених класів на усіх рівнях керує вбудована у NestJS реалізація патерну Dependency Injection.






3.2.	Побудова діаграми прецедентів для серверної частини системи


Проведемо концетуальне моделювання системи, враховуючи що у ній наявні два основні типи користувачів: звичайний користувач (клієнти мережі спортивних залів) та адміністратор.
Клієнтам буде доступне створення власного облікового запису, можливість починати тренування у певній залі, перегляд минулих тренувань та генерація порад згідно з показниками, що були отримані протягом тренування. Для початку тренування кожен користувач зможе використовувати свій IoT-пристрій, який після початку тренування зніматиме показники його тіла, на основі яких після тренування можна отримати рекомендації. Також користувачі можуть ставити собі цілі, обираючи з наявного списку їх типів, прогрес досягнення яких вони можуть занотовувати кожне тренування та потім відстежувати.
Адміністратори мережі спортивних залів, окрім можливостей, що наявні у звичайних користувачів, можуть використовувати власні облікові записи для входу у браузерний застосунок, через який виконується адміністрування системи. У ній вони можуть додавати нові спортивні зали, змінювати дані про вже існуючі, створювати нові облікові записи та надавати при цьому їм права адміністратора. Також можуть додавати нові типи цілей, що доступі користувачам.
На основі викладеного створено діаграму прецедентів (рис. А.2).


3.3.	Побудова ER-діаграми для серверної частини системи


З огляду на проведене концептуальне моделювання системи, можемо виділити наступні сутності, дані про яких будуть зберігатися:
•	Сутнність «Ціль» – містить інформацію про цілі, які створили для себе користувачі;
•	Сутнність «Прогрес цілі» – містить інформацію про певний прогрес цілі, який користувачі можуть додавати у застосунку щоденно.
•	Сутнність «Спортивна зала» – містить інформацію про існуючі спортивні зали;
•	Сутнність «Вимір» – містить інформацію про виміри, що було зроблені протягом певного тренування користувача. Створюються IoT-пристроєм;
•	Сутнність «Тренування» – містить інформацію про тренування, почате та закінчене користувачем.
•	Сутнність «Користувач» – містить дані про користувача такі як ім’я, прізвище, дата народження тощо.
На основі поданої інформації про сутності була створення ER-діаграма (рис. А.3).


3.4.	Специфікація REST


Наведемо для створеної програмної системи специфікацію REST.
Автентифікація:
•	POST auth/sign-up – реєстрація нового облікового запису користувачем.
Облікові записи:
•	GET users/:id – отримання інформації про обліковий запис користувача за індентифікатором;
•	PATCH users/:id – зміна інформації про обліковий запис користувача за індентифікатором;
•	DELETE users/:id – видалення облікового запису користувача за індентифікатором.
•	POST users/ – створення нового користувача, відрізняється від реєстрації можливісту надати користувачеві доступ до функціоналу адміністратора.
Спортивні зали:
•	POST gyms/ – створення нової спортивної зали;
•	GET gyms/ – отримання списку усіх наявних у системи спортивних зал;
•	GET gyms/:id – отримання інформації про спортивну залу за ідентифікатором;
•	PATCH gyms/:id – зміна інформації про спортивну залу за ідентифікатором;
•	DELETE gyms/:id – видалення спортивної зали за ідентифікатором.
Тренування:
•	POST trainings/start – початок нового тренування;
•	POST trainings/end – закінчення поточного активного тренування. Повертає помилку, якщо у цей момент немає жодного активного тренування;
•	GET trainings/active – повертає поточне активне тренування або нічого, якщо такого немає;
•	GET trainings/ – отримання усіх тренуваннь, включно із активним;
•	GET trainings/:id – отримання тренування по ідентифікатору;
•	DELETE trainings/:id – видалення минулого тренування по ідентифікатору;
•	POST trainings/:id/generate-recommendations – генерація рекомендацій до тренування, яке вже закінчили, з огляду на вимірювання, що були зняті під час цього тренування;
•	POST trainings/measure – створення нового вимірювання для активного тренування;
•	GET trainings/:trainingId/measurements – отримання усіх вимірювань для тренування за його ідентифікатором;
•	GET trainings/:trainingId/averages – отримання середніх вимірів температури та серцебиття протягом тренування.
Цілі
•	POST goals/ – створення нової цілі;
•	GET goals/ – отримання усіх цілей користувача;
•	GET goals/:id – отримання певної цілі за її ідентифікатором;
•	PATCH goals/:id – редагування певної цілі користувача за її ідентифікатором.
•	DELETE goals/:id – видалення певної цілі користувача за її ідентифікатором.
•	POST goals/:goalId/progress– додавання прогресу до певної цілі за її ідентифікатором;
•	PATCH goals/:goalId/progress/:id – зміна прогресу до певної цілі за ідентифікаторами цілі та прогресу;
•	DELETE goals/:goalId/progress/:id – видалення прогресу до певної цілі за ідентифікаторами цілі та прогресу


3.5.	Побудова діаграми пакетів для серверної частини системи


Спираючись на створену архітектуру серверної частини була визначена структура пакетів. Головним пакетом застосунку, що створюється за допомогою NestJS є пакет app, що об’єднує усі інші пакети застосунку, імпортуючи їх у себе. Також тут обов’язково відбувається конфігурація ORM та інших динамічних модулів. Даний пакет використовується файлом main.ts для створення застосунку та початку його роботи. На кореневому рівні пакети можуть містити файли контролеру, сервісу та модулю, власне який є серцем пакету та керує його залежностями.
Також пакети можуть включати наступні підпакети:
•	entities – містить сутності, якими оперує даний пакет;
•	dto – містить DTO (Data Transfer Objects), які визначають тіла запитів для контролеру у цьому пакеті;
•	decorators – містить декоратори, що дозволяє надавати класам доступ до певних залежностей, а також надавати їм та їх методам додатковий зовнішній функціонал;
•	guards – містить так звані Guards, що є спеціальними класами
•	Серед інших пакетів наявні:
•	Пакети для взаємодії з сутностями. На кожну окрему сутність було відведено окремий пакет. Сутність, домен якої тісно пов’язаний з іншою, головною сутністю, може бути частиною пакету цією сутності або ж мати вкладений пакет. Пакети сутнотей: goal, gym, measurement, training, user.
•	Пакет для взаємодії з автентифікацією auth – містить ендпоінт для реєстрації, а також декоратори та guards, що дозволяють захищати контролери та їх окремі методи від неавтентифікованих запитів, отримати дані про акаунт користувача та позначати методи як публічні у захищеному контролері;
•	Пакет для конфігурації config – містить сервіс, що конфігує доступ до змінних оточення, а також містить заготовлену конфігурацію підключення до бази даних;
•	Пакет firebase – містить динамічний модуль, що дозволяє ініціалізувати firebase у проєкті, за допомогою сервісного файлу та отримати доступ до послуг автентифікації. Також містить декоратор для впровадження об’єкту firebase застосунку іншим класам;
•	Пакет ai – містить сервіс для взаємодії із API Gemini від Google. Використовується для створення рекомендацій за допомогою штучного інтелекту.
Структура пакетів відображена на діаграмі пакетів (рис. А.4).
 
4	РОЗРОБКА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ ВБУДОВАНИХ СИСТЕМ
4.1.	Концептуальне моделювання системи


Перед розробкою частини платформи для вбудованих систем необхідно провести концептуальне моделювання програмного продукту. 
Ключовим аспектом вибору платформи являється можливість підключеня до Wi-Fi для взаємодії із сервером. Створений пристрій є ключовою ланкою між користувачем та сервером, надаючи дані, за якими користувач зможе отримувати персоналізовані рекомендації. 
Котролер має мати можливість робити запити до сервера, увійти в обліковий запис користувача, почати тренування разом зі зчитуванням даних про температуру, пульс та сповіщати користувача коли останній перевищує задане нормальне значення. А також має закінчувати зчитування коли тренування скінчене, про що буде надаватися інформація через відповідь серверу на запити з вимірюваннями.
Також користувач має змогу змінити посилання, за яким пристрій звертатиметься до серверної частини.
У відповідності до вищезазначеного, була розроблена UML діаграма прецедентів (рис. А.5).


4.2.	Опис розробки застосунку для вбудованих систем
4.2.1.	Обґрунтування архітектурних рішень проєкту


В основі розробки IoT частини системи лягла монолітна архітектура, як така, що забепечить найефективнішу роботу, зручну розробку та швидкий обмін даними між компонентами програмного забезпечення, без зайвих витрат на їх передачу, в умовах обмеженої обчислювальної здатності пристрою, на якому дане програмне забезпечення буде запускатися. Створене програмне забезпечення буде розбите на окремі модулі, згідно з їх функціоналом для покращення його підтримуваності.
Обмін даними між сервером та пристроєм буде відбуватися за допомогою HTTPS запитів, що робить пристрій до сконфігурованої адреси сервера.
Надсилання даних відбуватиметься кожну хвилину, а для обробки самих запитів IoT-пристрій надсилатиме токен, що ідентифікує користувача. Він буде отримаий завдяки попередній автентифікації в меню, що наявне у створеному програмого забезпеченні.
На основі поданого була створена UML діаграма взаємодії (рис. А.6).


4.2.2.	Опис використаних технологій


Платформою, під яку була проведена розробка став мікроконтролер ESP32 з використанням діалекту мови Python для мкроконтролерів Micropython. Через відсутність фізичної версія мікроконтролера був використаний симулятор для розробки IoT-пристроїв під назвою Wokwi. 
Усі використані пакети входять у стандартний набір Micropython, зокрема uresuests для запитів до серверної частини, dht для роботи із датчиком DHT22, utime для роботи з часом та його форматування.


4.2.3.	Опис результатів розробки частини проекту для вбудованих систем


Результатом розробки стало програмне забезпечення для контролеру ESP32, що інтегроване у програмну систему для моніторингу стану клієнтів мережі спортивних зал.
Після запуску пристрою проводиться конфігурація, налаштування підключення до мережі, після чого користувачеві показане головне меню.
Однією з опцій є налаштування посилання на серверну частину. При її обранні, користувач зможе ввести нове посилання, таким чином змінюючи адресу надсилання своїх показників.
Головною фунцією пристрою є старт тренування та відслідковування показників тіла протягом нього. Кожну хвилину датчик DHT22 вимірює температуру та пульс, надсилаючи їх на сервену частину. Якщо значення пульсу перевищує вказане граничне, девайс сповіщує користувача вмикаючи червоний світлодіод. Відповідно, коли значення пульсу повертається до нормального, світлодіод вимикається. Кожне вимірювання надсилається на сервер, де воно оброблюється та зберігається до бази даних. Кожен раз пристрій оброблює відповідь від серверу, перевіряючи чи не було тренування закінчено. Якщо тренування продовжується, девайс чекає хвилину і знову проводить цикл вимірювання показникві. В іншому ж випадку він перестає знімати показання та закінчує роботу.
Детальніше принцип роботи створеного програмного забезпечення для IoT пристрою наведено в UML діаграмі станів (рис. А.7).


4.2.4.	Опис результатів тестування частини проекту для вбудованих систем


Після закінчення розробки було проведено функціональне тестування застосунку безпосередньо у симуляторі Wokwi.
Протягом тестування була перевірена стабільність роботи застосунку та його коректна обробка відповідей від серверу.
 
5	РОЗРОБКА КЛІЄНТСЬКОГО ВЕБ-ЗАСТОСУНКУ
5.1.	Концептуальне моделювання системи


Перед початком розробки клієнтської частини створюваної програмної системи необхідно провести концептуальне моделювання продукту.
До створеного застосунку має мати доступ лише адміністратор, оскільки через нього буде виконуватися адміністрування системи. Адміністратору має буде доступна можливість додавати нові спортивні зали та видаляти, редагувати вже існуючі, додавати нові статті та редагувати, видаляти вже існуючі, додавати нових адміністраторів, а також віддалено запускати створення резервних копій бази даних. 
З огляду на вищезазначене була розроблена UML діаграма прецедентів (рис. А.10).


5.2.	Опис розробки клієнтського веб-застосунку
5.2.1.	Обґрунтування архітектурних рішень проєкту


З огляду на використані технології та міркувань щодо підтримуваності, швидкодії застосунку, було прийнято рішення використовувати компонентно-орієнтовану архітектуру.
Таким чином вся частина система була розділена на окремі незалежні компоненти, що можуть комунікувати між собою тільки через заздалегідь визначені властивості. Завдяки цьому була покращена якість коду, а самі частини стали менш зв'язаними, завдяки чому також була покращена їх тестованість.
Конфігурація посилань на серверну частину та інші чутливі дані зберігаються у спеціальному файлі оточення.
Обмін даними із серверною частиною виконується через HTTPS запити по заздалегідь визначеним шляхам. Таким чином клієнтська частина виконує асинхронні запити, не блокуючи інтерфейс протягом завантаження даних. Сервер та клієнт обмінюються даними у форматі JSON.
Застосунок підтримує англійську та українську локалізації. Список мов може бути легко розширений, додавши відповідний файл з перекладами для застосунку.
Автентифікація була реалізована за допомогою сервісу Firebase Authentication, а сервер у свою чергу перевіряє при цьому виданий токен на автентичність при виконанні запитів до нього.
Для демонстрацїі структури створеної системи, з огляду на її аріхектуру, була створена UML діаграма компонентів (рис. А.11).


5.2.2.	Опис використаних технологій


Для розробки була використана мова TypeScript та бібліотека React. Завдяки цьому була забезпечена швидкодія додатку, покращена якість розробки, а безпека типів забезпечує кращу передбачуваність системи та її стійкість до недійсних даних. Також була використана бібліотека Mantine, як основа дизайн-системи застосунку. Компоненти, з яких складається системи побудовані на базі компонентів, що надає дана бібліотека.
Для автентифікації було використано Firebase JavaScript SDK.
Для локалізації використано i18next, а також react-i18next, що є розширенням для першої бібліотеки, для більш зручного використання разом з бібліотекою React.
Для демонстрації використаних пакетів була створена UML діаграма пакетів (рис. А.12).



5.2.3.	Опис результатів розробки клієнтського веб-застосунку


Результатом розробки програмного забезпечення для браузерної клієнтської частини системи став застосунок, що дозволяє адміністрування системи для моніторингу стану та персоналізації досвіду клієнтів мережів спортивних зал.
При вході у застосунок користувачеві буде запропоновано увійти в існуючий обліковий запис. Опція реєстрації відсутня, оскільки дана частина доступна лише адміністраторам і відповідні облікові записи можуть створювати лише інші адміністратори.
У верхній частині сторінки доступне меню для вибору мови.
Користувачеві доступні 4 розділи: «Спортивні зали», «Статті», «Адміністратори» та «Резервні копії».
У розділі «Спортивні зали» адміністратор має змогу керувати наявними у системі спортивними залами, що включає їх переглядання, видалення та редагування вже існуючих, а також створення нових. Створення нової спортивної зали відбувається на окремій сторінці, на котру можна перейти за допомогою кнопки «Додати».
У розділі «Статті» адміністратор має змогу керувати наявними у системі статтями, що включає їх переглядання, видалення та редагування вже існуючих, а також створення нових. Створення нової статті відбувається на окремій сторінці, на котру можна перейти за допомогою кнопки «Додати». У формі додавання статті можливо додати їй заголовок, основний контент у вигляді Markdown, теги по яким подану статтю можна буде знайти, а також картинку для обкладинки.
У розділі «Адмінстратор» знаходиться інтерфейс для створення нових облікових записів адміністраторів. Можливо переглядати вже існуючі, а також додавати нові за допомогою кнопки «Додати».
У розділі «Резервні копії» знаходиться інтерфейс для керування резервними копіями бази даних. Створення резервних копій відбувається за допомогою окремого сервісу на сервері, що працює на Express. У цьому розділі доступний зручний перегляд вже існуючих копій по датам, а також кнопка для відправки запиту на нову резервну копію, після чого нова копія буде додана у список.
Детальніше принцип роботи браузерного клієнта наведено в UML діаграмі діяльності (рис. А.13).


5.2.4.	Опис результатів тестування клієнтського веб-застосунку


Після закінчення розробки системи було проведено її функціональне тестування з використанням браузера Google Chrome та операційної системи Windows 10.
Протягом тестування була перевірена стабільність роботи застосунку, коректність виводу інформації та його комунікації із сервером.
 
6	РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ
6.1.	Концептуальне моделювання системи


Перед початком розробки мобільного застосунку в якості частини створюваної програмної системи для моніторингу стану та персоналізації досвіду клієнтів мережі спортивних залів необхідно провести концептуальне моделювання продукту.
Упродовж користування створеним програмним забезпеченням, цільовою авдиторією якого є саме клієнти мережі спортивних залів, користувачам буде надано різноманітні можливості, а саме: перегляд усіх попередніх тренувань разом із активним, можливість зазначити тренування як закінчене, перегляд графічної репрезентації змін показників тіла протягом тренування, отримання персоналізованих рекомендацій згідно з отриманими вимірюваннями, перегляд доступних у мережі спортивних, пошук та детальний перегляд статтей.
З огляду на вищезазначене була розроблена UML діаграма прецедентів (рис. А.14). 


6.2.	Опис розробки мобільного застосунку
6.2.1.	Обґрунтування архітектурних рішень проєкту


При визначенні архітектурного підходу, що буде використовуватися протягом розробки, було прийнято рішення використовувати змішану архітектуру у вигляді патерну MVVM (Model-View-ViewModel) та компонентно-орієнтованої архітектури. Внаслідок цього застосунок буде значно легше підтримувати, а його частини будуть менш зв’язаними та зможуть бути більш ефективно перевикористані.
Увесь інтерфейс розбито на окремі компоненти, що взаємодіють між собою тільки за допомогою заздалегідь визначених властивостей. Кожен компонент може мати власний стан, що зазвичай керує його візуальними аспектами, а також змінюватися в залежності від властивостей, що йому були передані, а також отримувати стан з моделей представлення. Моделі представлення, або ж ViewModels, відповідають за основну бізнес логіку застосунку. Саме в них відбувається обробка даних, що були отримані з серверу. Компоненти підписуються на зміни даних у моделях представлення і таким чином перевикористовують ті самі дані та змінюють їх кожен по-своєму.
Конфігураця застосунку відбувається за допомогою файлу зі змінними оточення, який підвантажується програмним забезпеченням протягом процесу збірки, а також за допомогою сервісного файлу google, що відповідає за взаємодію з сервісом Firebase.
Застосунок підтримує українську та англійську локалізації. Додавання нових перекладів вимагає створення відповідного файлу-ресурсу.
Взаємодія з сервером відбувається за допомогою спеціальних API-класів, що надсилають до нього асинхронні HTTP-запити, отримуючи та надсилаючи дані.
Прийняті архітектурні рішення детальніше відображені на діаграмі компонентів (рис. А.15).


6.2.2.	Опис використаних технологій


Основою шару представлення створеного застосунку є фреймворк Jetpack Compose, що дозволяє описувати клієнтський інтерфейс у вигляді окремих незалежних компонентів, шляхом їх об'єднання в одне ціле за допомогою композиції. Також було використано бібліотеку Material3, що містить широкий спектр готових до використанн компонентів, а також зручні шляхи їх кастомізації, що значно пришвидшило розробку.
Головна логіка застосунку містить у шарі бізнес-логіки, що представлений класами ViewModel. Усі компоненти отримують доступ до даних та методів з однакових, заздалегідь створених об’єктів моделей представлення, що надаються їм спеціальними постачальниками.
Локалізація застосунку реалізована за допомогою вбудованих можливостей операційної системи Android.
Шар доступу до даних реалізовано за допомогою KTOR Client.
Структура залежностей застосунку детальніше зображена на UML діаграмі пакетів (рис. А.16).


6.2.3.	Опис результатів розробки мобільного застосунку


Результатом проведеної розробки став мобільний застосунок для програмної системи для моніторингу стану та персоналізації досвіду клієнтів мережі спортивних залів.
При першому вході користувачеві пропонується зареєструватися або ж увійти в наявний у системі акаунт за допомогою пошти та паролю. При невдалій автентифікації виводиться відповідне повідомлення про помилку.
Після успішної автентифікації користувач потрапляє на екран зі історією його тренувань. У нижній частині екрану доступні три розділи: «Тренування», «Спортивні зали» та «Статті». Саме з першого користувач починає роботу із застосунком.
У розділі «Тренування» користувач може побачити свої попередні тренування, а також поточне, що за наявності завжди знаходиться на початку списку та виділяється з-поміж іншиї. На кожне з тренувань можна натиснути, щоб перейти на сторінку із його деталями. Активне тренування можливо закінчити, а також переглядати графіки із вже доступними вимірюваннями. Для закінчених тренувань також доступний перегляд даних тренування, а також створення персоналізованих порад згідно із зібраними вимірюваннями тіла.
У розділі «Спортивні зали» користувачі можуть побачити список спортивних залів що є у мережі разом із їх адресою.
У розділі «Статті» користувачі можуть шукати статті за допомогою відповідного поля та переглядати їх детальний зміст, перейшовши на сторінку самої статті.
Дані на певних сторінках можливо оновлювати за допомогою проведення пальцем згори донизу.
На усіх екранах у верхній панелі інтерфейсу доступна зміна мови, а також для автентифікованих користувачів наявна кнопка виходу з облікового запису.
Детальніше принцип роботи мобільного застосунку наведено в UML діаграмі діяльності (рис. А.17).


6.2.4.	Опис результатів тестування мобільного застосунку


Після закінчення розробки мобільного клієнтського застосунку було проведено її функціональне тестування з використанням емулятора смартфону Google Pixel 6 під операційною системою Android 13 (API 33).
Протягом тестування була перевірена стабільність застосунку, коректна робота із сервером, а саме надсилання запитів та обробка відповідей, а також загальна зручність та зрозумілість інтерфейсу.
 
ВИСНОВКИ


На початкоку було проведено концептуальне моделювання предметної област. Були проаналізовані наявні на ринку аналоги, потенційні бізнес можливості, потреби клієнтів та ринку, які необхідно задовольнити створюваним продуктом та бізнес ризики, з якими проєкт може стикнутися протягом його реалізації. На основі цього були сформовані вимоги до програмної системи та її функціоналу, визначено робоче середовище.
При розробці було детально описано розгортання системи, її архітектура та наявні у ній сутності, взаємодію між ними. Ці аспекти було детальніше проілюстровано у вигляді UML діаграм. Була наведена специфікація REST.
Протягом виконання решти частин системи, а саме: програмного забезпечення для вбудованих систем, браузерного веб-клієнту та мобільного застосунку, для кожної з них провели концептуальне моделювання, обґрунтовано прийняті архітектурні рішення, описано використані технології, результати розробки та тестуванні створеної програмної реалізації.
Результатом розробки стала програмна система для моніторингу стану та персоналізації досвіду клієнтіві мережі спортивних залів. Система складається з чотирьох частин: серверної, що є серцем системи та надає доступ до даних та функціоналу для інших частин, браузерної, мобільної та частини для вбудованих систем. Для серверної частини було використано фреймворк NestJS з мовою TypeScript, в якості СКБД – PostgreSQL, платформа ESP32 та мова MicroPython для створення частини для вбудованих систем, бібліотека React та бібліотека Mantine для створення браузерного клієнту та мова Kotlin із використанням фреймворку Jetpack Compose для розробки мобільного застосунку.
 
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ


1.	Репозиторій проєкту на платформі Github. URL: https://github.com/NureKlymenkoOleksandr/apzkr-pzpi-21-2-klymenko-oleksandr (дата звернення: 21.06.2024).
2.	NestJS Documentation. NestJS –  A progressive Node.js framework. URL: https://docs.nestjs.com/ (дата звернення: 21.06.2004).
3.	Wokwi Documentation. Wokwi –  Online ESP32, STM32, Arduino Simulator. URL: https://docs.wokwi.com/ (дата звернення: 21.06.2004).
4.	React Documentation. React. URL: https://react.dev/learn (дата звернення: 21.06.2004).
5.	Jetpack Compose Documentation. Google. URL: https://developer.android.com/develop/ui/compose/documentation (дата звернення: 21.06.2004).
6.	Відеозапис функціонального тестування розробленої програмної системи. URL: https://youtu.be/p3MJ42MAeTI (дата звернення 23.06.2024).
 
ДОДАТОК А
Діаграми

А.1 UML діаграма розгортання системи

 
Рисунок А.1 – UML діаграма розгортання системи
 
А.2 UML діаграма прецедентів серверної частини

 
 
Рисунок А.2 – UML діаграма прецедентів серверної частини
 
А.3 ER-діаграма

 
Рисунок А.3 – ER-діаграма
 
А.4 UML діаграма пакетів серверної частини

 
Рисунок А.4 – UML діаграма пакетів серверної частини
 
А.5 UML діаграма прецедентів частини для вбудованих систем

 
Рисунок А.5 – UML діаграма прецедентів частини для вбудованих систем
 
А.6 UML діаграма взаємодії частини для вбудованих систем

 
Рисунок А.6 UML діаграма взаємодії частини для вбудованих систем
А.7 UML діаграма станів частини для вбудованих систем

 
Рисунок А.7 – UML діаграма станів частини для вбудованих систем
 
А.8 UML діаграма діяльності частини для вбудованих систем

 
Рисунок А.8 – UML діаграма діяльності частини для вбудованих систем
 
А.9 Схема фіізичної моделі частини для вбудованих систем

 
Рисунок А.9 – Схема фіізичної моделі частини для вбудованих систем
 
А.10 UML діаграма прецедентів веб клієнту

 
Рисунок А.10 – UML діаграма прецедентів веб клієнту
 
А.11 UML діаграма компонентів веб-клієнту

 
Рисунок А.11 – UML діаграма компонентів веб-клієнту

А.12 UML діаграма пакетів веб-клієнту

 
Рисунок А.12 – UML діаграма пакетів веб-клієнту


А.13 UML діаграма діяльності веб-клієнту

 
Рисунок А.13 – UML діаграма діяльності веб-клієнту
 

А.14 UML діаграма прецедентів мобільної частини

 
Рисунок А.14 – UML діаграма прецедентів мобільної частини
 
А.15 UML діаграма компонентів мобільної частини

 
Рисунок А.15 – UML діаграма компонентів мобільної частини
 
А.16 UML діаграма пакетів мобільної частини

 
Рисунок А.16 – UML діаграма пакетів мобільної частини
 
А.17 UML діаграма діяльності мобільної частини
 
Рисунок А.17 – UML діаграма діяльності мобільної частини
 
ДОДАТОК Б
Фрагменти коду програми

Б.1 Стартовий файл серверної частини 

1 import { NestFactory, Reflector } from '@nestjs/core';
 2 import { AppModule } from './app.module';
 3 import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
 4 import { ClassSerializerInterceptor, ValidationPipe } from '@nestjs/common';
 5
 6 async function bootstrap() {
 7   async function bootstrap() {
 8     const app = await NestFactory.create(AppModule);
 9     app.enableCors();
10
11     const config = new DocumentBuilder()
12       .setTitle('Fit Guru API')
13       .setDescription('API for Fit Guru sport application')
14       .setVersion('1.0')
15       .addBearerAuth(
16         {
17           type: 'http',
18           scheme: 'bearer',
19           bearerFormat: 'JWT',
20           description: 'Input your JWT token',
21           name: 'Authorization',
22           in: 'header',
23         },
24         'bearer',
25       )
26       .build();
27     const document = SwaggerModule.createDocument(app, config);
28     SwaggerModule.setup('api', app, document);
29     app.useGlobalPipes(new ValidationPipe());
30
31     app.useGlobalInterceptors(
32       new ClassSerializerInterceptor(app.get(Reflector)),
33     );
34
35     await app.listen(3000);
36   }
37   bootstrap();
38 }
39 bootstrap();

Б.2 Файл модулю для взаємодії з Firebase

1  import { DynamicModule, Global, Module, Provider } from '@nestjs/common';
 2
 3  import { FirebaseApp, FirebaseModuleOptions } from './firebase.types';
 4  import { FIREBASE_INSTANCE_TOKEN } from './firebase.constants';
 5  import { initializeApp, cert } from 'firebase-admin/app';
 6  import { getAuth } from 'firebase-admin/auth';
 7
 8  import { getFirestore } from 'firebase-admin/firestore';
 9
10  const getFirebaseAppInstance = (options: FirebaseModuleOptions) => {
11    const { credential, ...rest } = options;
12    return initializeApp({
13      credential: cert(options.credential),
14      ...rest,
15    });
16  };
17
18  @Global()
19  @Module({})
20  export class FirebaseModule {
21    static forRoot(options: FirebaseModuleOptions): DynamicModule {
22      const firebaseAdmin = getFirebaseAppInstance(options);
23      const firebaseProvider: Provider<FirebaseApp> = {
24        provide: FIREBASE_INSTANCE_TOKEN,
25        useValue: {
26          auth: getAuth(firebaseAdmin),
27          firestore: getFirestore(firebaseAdmin),
28        },
29      };
30
31      return {
32        providers: [firebaseProvider],
33        module: FirebaseModule,
34        exports: [firebaseProvider],
35      };
36    }
37  }

Б.3 Файл сервісу для взаємодії зі штучним інтелектом

1  import { Injectable } from '@nestjs/common';
 2  import { ConfigService } from 'src/config';
 3  import { GenerativeModel, GoogleGenerativeAI } from '@google/generative-ai';
 4  import { Measurement } from 'src/measurement/entities';
 5
 6  @Injectable()
 7  export class AiService {
 8    private readonly genAi: GoogleGenerativeAI;
 9    private readonly genAiModel: GenerativeModel;
10
11    constructor(private readonly configService: ConfigService) {
12      this.genAi = new GoogleGenerativeAI(this.configService.getGeminiApiKey());
13      this.genAiModel = this.genAi.getGenerativeModel({
14        model: 'gemini-1.5-flash',
15      });
16    }
17
18    async recommendationPrompt(measurements: Measurement[]) {
19      const measurementsString = measurements
20        .map(
21          (item) =>
22            `Heart rate: ${item.heartRate}; Temperature: ${item.temperature}°C at ${item.date.getHours()}:${item.date.getMinutes()}`,
23        )
24        .join('\n');
25      const prompt = this.configService
26        .getRecommendationPrompt()
27        .replace('*measurements*', measurementsString);
28      const result = await this.genAiModel.generateContent(prompt);
29      console.log(`AI response: ${result.response.text()}`);
30      return result.response.text();
31    }
32  }

Б.4 Файл сервісу для тренувань

1  import {
 2    ConflictException,
 3    Injectable,
 4    NotFoundException,
 5  } from '@nestjs/common';
 6  import { StartTrainingDto } from './dto/start-training.dto';
 7  import { InjectRepository } from '@nestjs/typeorm';
 8  import { Training } from './entities/training.entity';
 9  import { Equal, IsNull, Repository } from 'typeorm';
10  import { UserService } from 'src/user/user.service';
11  import { AiService } from 'src/ai/ai.service';
12  import { GymService } from 'src/gym/gym.service';
13
14  @Injectable()
15  export class TrainingService {
16    constructor(
17      @InjectRepository(Training)
18      private readonly trainingRepository: Repository<Training>,
19      private readonly userService: UserService,
20      private readonly aiService: AiService,
21      private readonly gymService: GymService,
22    ) {}
23
24    async start(userId: string, startTrainingDto: StartTrainingDto) {
25      const user = await this.userService.findOne(userId);
26      const gym = await this.gymService.findOne(startTrainingDto.gymId);
27      const trainingInProgress = await this.findActiveTraining(userId);
28      if (trainingInProgress) {
29        throw new ConflictException('User already has a training in progress');
30      }
31      const training = this.trainingRepository.create({
32        startDate: new Date(),
33      });
34      training.gym = gym;
35      training.user = user;
36      return this.trainingRepository.save(training);
37    }
38
39    async end(userId: string) {
40      const training = await this.findActiveTraining(userId);
41      if (!training) {
42        throw new ConflictException('User has no active training at the moment.');
43      }
44      const mergedTraining = this.trainingRepository.merge(training as Training, {
45        endDate: new Date(),
46      });
47      return this.trainingRepository.save(mergedTraining);
48    }
49
50    async findActiveTraining(userId: string) {
51      return this.trainingRepository.findOne({
52        where: {
53          user: {
54            id: userId,
55          },
56          endDate: IsNull(),
57        },
58        relations: ['gym', 'measurements'],
59      });
60    }
61
62    async findAllByUserId(userId: string) {
63      return this.trainingRepository.find({
64        where: {
65          user: {
66            id: Equal(userId),
67          },
68        },
69        relations: ['gym', 'measurements'],
70        order: {
71          startDate: {
72            direction: 'DESC',
73            nulls: 'FIRST',
74          },
75          measurements: {
76            date: 'ASC',
77          },
78        },
79      });
80    }
81
82    async findOne(id: string) {
83      const training = await this.trainingRepository.findOne({
84        where: { id },
85        relations: ['gym', 'measurements'],
86        order: {
87          measurements: {
88            date: 'ASC',
89          },
90        },
91      });
92
93      if (!training) {
94        throw new NotFoundException(`No training with ID ${id}`);
95      }
96
97      return training;
98    }
99
100    async remove(id: string) {
101      const training = await this.findOne(id);
102      await this.trainingRepository.remove(training);
103    }
104
105    async generateRecommendations(id: string) {
106      const training = await this.findOne(id);
107      if (training.recommendations) {
108        throw new ConflictException(
109          `Training with ID ${id} already has recommendations generated.`,
110        );
111      }
112      const aiResponse = await this.aiService.recommendationPrompt(
113        training.measurements,
114      );
115      training.recommendations = aiResponse;
116      return this.trainingRepository.save(training);
117    }
118  }

Б.5 Метод для початку тренування програми для вбудованих систем

1  def start_training(self):
 2      constants.CLEAR_TERMINAL()
 3      if not constants.FIREBASE_ID_TOKEN:
 4          print("You must be authenticated to start training.")
 5          return
 6      self.http_service.start_training()
 7      shouldMeasure = True
 8      while shouldMeasure:
 9          shouldMeasure = self.measure_and_check_for_end()
10      print("We hope you had a great training!")
11      constants.SLEEP(3)

Б.6 Метод для вимірювання та надсилання показників тіла програми для вбудованих систем

1  def measure_and_check_for_end(self):
 2      self.sensor.measure()
 3      temperature = self.sensor.temperature()
 4      heartRate = round(self.sensor.humidity() + 40)
 5      trainingActive = self.http_service.send_measurement(heartRate, temperature)
 6      if heartRate >= constants.MAX_NORMAL_HEARTBEAT:
 7          self.ledOn()
 8      else:
 9          self.ledOff()
10      if trainingActive:
11          print(f"Logged heart rate: {heartRate}; temperature: {temperature}")
12          constants.SLEEP(constants.LOGGING_INTERVAL)
13      return trainingActive

Б.7 Сервіс для взаємодії із сервером програми для вбудованих систем

1  import constants
 2  import urequests
 3  from utils import get_iso_date
 4
 5  class HttpService:
 6      def sign_in(self, email, password):
 7          url = f"{constants.FIREBASE_LOGIN_ENDPOINT}?key={constants.FIREBASE_API_KEY}"
 8          payload = {
 9              "email": email,
10              "password": password,
11              "returnSecureToken": True
12          }
13          headers = {
14              "Content-Type": "application/json",
15          }
16
17          response = urequests.post(url, json=payload, headers=headers)
18          if response.status_code == 200:
19              constants.FIREBASE_ID_TOKEN = response.json()['idToken']
20              return True
21          else:
22              return False
23
24
25      def send_measurement(self, heartRate, temperature):
26          url = f"{constants.API_BASE_URL}/trainings/measure"
27          payload = {
28              "heartRate": heartRate,
29              "temperature": temperature,
30              "date": get_iso_date()
31          }
32          headers = {
33              "Content-Type": "application/json",
34              "ngrok-skip-browser-warning": "true",
35              "Authorization": f"Bearer {constants.FIREBASE_ID_TOKEN}",
36          }
37
38          response = urequests.post(url, json=payload, headers=headers)
39          return response.status_code == 201
40
41
42      def start_training(self):
43          url = f"{constants.API_BASE_URL}/trainings/start"
44          headers = {
45              "Content-Type": "application/json",
46              "ngrok-skip-browser-warning": "true",
47              "Authorization": f"Bearer {constants.FIREBASE_ID_TOKEN}",
48          }
49          response = urequests.post(url, headers=headers)
50          responseJson = response.json()
51          if response.status_code == 200 and responseJson:
52              constants.ACTIVE_TRAINING_ID = responseJson['id']
53              return True
54          else:
55              return False

Б.8 Файл конфігурації локалізації веб-клієнту

1  import { ComboboxData } from "@mantine/core";
 2  import i18n from "i18next";
 3  import { initReactI18next } from "react-i18next";
 4  import LanguageDetector from "i18next-browser-languagedetector";
 5
 6  import en from "./locales/en.json";
 7  import uk from "./locales/uk.json";
 8
 9  export const AVAILABLE_LOCALES: ComboboxData = [
10    {
11      label: "English",
12      value: "en",
13    },
14    {
15      label: "Українська",
16      value: "uk",
17    },
18  ];
19
20  i18n
21    .use(LanguageDetector)
22    .use(initReactI18next)
23    .init({
24      resources: {
25        en,
26        uk,
27      },
28      fallbackLng: "en",
29      detection: {
30        order: [],
31      },
32    });

Б.9 Контекст автентифікації веб клієнту

1  import {
 2    User,
 3    UserCredential,
 4    createUserWithEmailAndPassword,
 5    onAuthStateChanged,
 6    signInWithEmailAndPassword,
 7    signOut,
 8  } from "firebase/auth";
 9  import {
10    createContext,
11    useCallback,
12    useContext,
13    useEffect,
14    useMemo,
15    useState,
16  } from "react";
17  import { auth } from "@/lib/firebase";
18
19  type AuthContextState = {
20    user: User | null;
21    loading: boolean;
22    createUser: (email: string, password: string) => Promise<UserCredential>;
23    loginUser: (email: string, password: string) => Promise<UserCredential>;
24    logOut: () => Promise<void>;
25  };
26
27  export const AuthContext = createContext<AuthContextState | null>(null);
28
29  export const AuthProvider = ({ ...rest }) => {
30    const [user, setUser] = useState<User | null>(null);
31    const [loading, setLoading] = useState(true);
32
33    const createUser = useCallback((email: string, password: string) => {
34      setLoading(true);
35      return createUserWithEmailAndPassword(auth, email, password);
36    }, []);
37
38    const loginUser = useCallback((email: string, password: string) => {
39      setLoading(true);
40      return signInWithEmailAndPassword(auth, email, password);
41    }, []);
42
43    const logOut = useCallback(() => {
44      setLoading(true);
45      return signOut(auth);
46    }, []);
47
48    useEffect(() => {
49      const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
50        setUser(currentUser);
51        setLoading(false);
52      });
53
54      return () => {
55        unsubscribe();
56      };
57    }, []);
58
59    const value = useMemo(
60      () => ({
61        user,
62        loading,
63        createUser,
64        loginUser,
65        logOut,
66      }),
67      [user, loading, createUser, loginUser, logOut]
68    );
69
70    return <AuthContext.Provider {...rest} value={value} />;
71  };
72
73  export const useAuth = () => {
74    const authContext = useContext(AuthContext);
75
76    if (!authContext) {
77      throw new Error("Should be used inside AuthProvider");
78    }
79
80    return authContext;
81  };

Б.10 Файл головної активності мобільного застосунку

1  package com.oleksandrklymenko.fitguru
 2
 3  import android.os.Bundle
 4  import androidx.activity.compose.setContent
 5  import androidx.activity.enableEdgeToEdge
 6  import androidx.appcompat.app.AppCompatActivity
 7  import androidx.compose.foundation.layout.Box
 8  import androidx.compose.foundation.layout.fillMaxSize
 9  import androidx.compose.foundation.layout.padding
10  import androidx.compose.material3.CircularProgressIndicator
11  import androidx.compose.material3.Scaffold
12  import androidx.compose.runtime.Composable
13  import androidx.compose.runtime.CompositionLocalProvider
14  import androidx.compose.runtime.collectAsState
15  import androidx.compose.runtime.getValue
16  import androidx.compose.ui.Alignment
17  import androidx.compose.ui.Modifier
18  import androidx.lifecycle.viewmodel.compose.viewModel
19  import androidx.navigation.compose.rememberNavController
20  import com.oleksandrklymenko.fitguru.navigation.LocalNavController
21  import com.oleksandrklymenko.fitguru.navigation.auth.AuthNavGraph
22  import com.oleksandrklymenko.fitguru.navigation.main.MainNavGraph
23  import com.oleksandrklymenko.fitguru.ui.BottomBar
24  import com.oleksandrklymenko.fitguru.ui.TopBar
25  import com.oleksandrklymenko.fitguru.ui.theme.MyApplicationTheme
26  import com.oleksandrklymenko.fitguru.viewmodels.AuthState
27  import com.oleksandrklymenko.fitguru.viewmodels.AuthViewModel
28  import com.oleksandrklymenko.fitguru.viewmodels.LocalAuthViewModel
29
30  class MainActivity : AppCompatActivity() {
31      override fun onCreate(savedInstanceState: Bundle?) {
32          super.onCreate(savedInstanceState)
33          enableEdgeToEdge()
34          setContent {
35              MyApplicationTheme {
36                  App()
37              }
38          }
39      }
40  }
41
42  @Composable
43  fun App() {
44      val navController = rememberNavController()
45      val authViewModel: AuthViewModel = viewModel()
46
47      val authState by authViewModel.authState.collectAsState()
48
49      CompositionLocalProvider(LocalAuthViewModel provides authViewModel, LocalNavController provides navController) {
50          Scaffold(
51              topBar = { TopBar() },
52              bottomBar = {
53                  if (authState is AuthState.Authenticated) {
54                      BottomBar()
55                  }
56              }
57          ) { innerPadding ->
58              Box(
59                  modifier = Modifier
60                      .fillMaxSize()
61                      .padding(innerPadding),
62                  contentAlignment = Alignment.Center
63              ) {
64                  when (authState) {
65                      is AuthState.Authenticated -> MainNavGraph()
66                      is AuthState.Unauthenticated, is AuthState.Error -> AuthNavGraph()
67                      else -> {
68                          CircularProgressIndicator()
69                      }
70                  }
71              }
72          }
73      }
74  }

Б.11 Файл моделі представлення для тренувань у мобільному застосунку

1  package com.oleksandrklymenko.fitguru.viewmodels
 2
 3  import androidx.compose.runtime.staticCompositionLocalOf
 4  import androidx.lifecycle.ViewModel
 5  import androidx.lifecycle.viewModelScope
 6  import com.oleksandrklymenko.fitguru.models.Training
 7  import com.oleksandrklymenko.fitguru.models.TrainingApiImpl
 8  import com.oleksandrklymenko.fitguru.network.HttpClientProvider
 9  import kotlinx.coroutines.flow.MutableStateFlow
10  import kotlinx.coroutines.flow.StateFlow
11  import kotlinx.coroutines.flow.asStateFlow
12  import kotlinx.coroutines.launch
13
14  class TrainingViewModel : ViewModel() {
15      private val trainingApi = TrainingApiImpl(HttpClientProvider.client)
16
17      private val _trainings = MutableStateFlow<List<Training>>(emptyList())
18      val trainings: StateFlow<List<Training>> = _trainings.asStateFlow()
19
20      private val _loadingTrainings = MutableStateFlow(false)
21      val loadingTrainings = _loadingTrainings.asStateFlow()
22
23      fun fetchTrainings() {
24          _loadingTrainings.value = true
25          viewModelScope.launch {
26              val trainings = trainingApi.getTrainings()
27              _trainings.value = trainings
28              _loadingTrainings.value = false
29          }
30      }
31
32      init {
33          fetchTrainings()
34      }
35
36      private var _selectedTraining = MutableStateFlow<Training?>(null)
37      val selectedTraining: StateFlow<Training?> = _selectedTraining.asStateFlow()
38
39      private fun replaceTrainingInList(training: Training) {
40          val existingTrainingId = _trainings.value.indexOfFirst {
41              it.id == training.id
42          }
43
44          if (existingTrainingId > -1) {
45              _trainings.value = _trainings.value.mapIndexed { i, existing ->
46                  if (i == existingTrainingId) training else existing
47              }
48          }
49      }
50
51      fun selectTraining(training: Training) {
52          _selectedTraining.value = training
53      }
54
55      fun getTraining(id: String) {
56          viewModelScope.launch {
57              val currentTraining = trainingApi.getTraining(id)
58              _selectedTraining.value = currentTraining
59              replaceTrainingInList(currentTraining)
60          }
61      }
62
63      fun finishTraining() {
64          viewModelScope.launch {
65              val finishedTraining = trainingApi.finishTraining()
66              _selectedTraining.value = finishedTraining
67              replaceTrainingInList(finishedTraining)
68          }
69      }
70
71      fun generateRecommendations() {
72          viewModelScope.launch {
73              val training = selectedTraining.value
74              if (training != null) {
75                  val trainingWithRecommendations = trainingApi.generateRecommendations(training.id)
76                  _selectedTraining.value = trainingWithRecommendations
77              }
78          }
79      }
80  }
81
82  val LocalTrainingViewModel = staticCompositionLocalOf<TrainingViewModel> { error("No TrainingViewModel provided") }
